// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/codegen_test.go
// Generated: 2025-07-12T20:47:46-07:00

package xdr_test

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"

)

func (v *Operation) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.OpCode)); err != nil {
	return fmt.Errorf("failed to encode OpCode: %w", err)
}

	if err := enc.EncodeBytes(v.Result); err != nil {
		return fmt.Errorf("failed to encode Result: %w", err)
	}

	return nil
}
func (v *Operation) Decode(dec *xdr.Decoder) error {

	
OpCodeTmp, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode OpCode: %w", err)
}
v.OpCode = OpCode(OpCodeTmp)

	tempResult, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Result: %w", err)
	}
v.Result = tempResult

	return nil
}
var _ xdr.Codec = (*Operation)(nil)

func (v *OpReadResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeBool(v.Success); err != nil {
		return fmt.Errorf("failed to encode Success: %w", err)
	}

	if err := enc.EncodeBytes(v.Data); err != nil {
		return fmt.Errorf("failed to encode Data: %w", err)
	}

	return nil
}
func (v *OpReadResult) Decode(dec *xdr.Decoder) error {

	tempSuccess, err := dec.DecodeBool()
	if err != nil {
		return fmt.Errorf("failed to decode Success: %w", err)
	}
v.Success = tempSuccess

	tempData, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Data: %w", err)
	}
v.Data = tempData

	return nil
}
var _ xdr.Codec = (*OpReadResult)(nil)

func (v *OpWriteResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.BytesWritten); err != nil {
		return fmt.Errorf("failed to encode BytesWritten: %w", err)
	}

	return nil
}
func (v *OpWriteResult) Decode(dec *xdr.Decoder) error {

	tempBytesWritten, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode BytesWritten: %w", err)
	}
v.BytesWritten = tempBytesWritten

	return nil
}
var _ xdr.Codec = (*OpWriteResult)(nil)

func (v *TestUser) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(string(v.ID)); err != nil {
	return fmt.Errorf("failed to encode ID: %w", err)
}

	if err := enc.EncodeBytes([]byte(v.Session)); err != nil {
	return fmt.Errorf("failed to encode Session: %w", err)
}

	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
	return fmt.Errorf("failed to encode Status: %w", err)
}

	if err := enc.EncodeUint64(uint64(v.Flags)); err != nil {
	return fmt.Errorf("failed to encode Flags: %w", err)
}

	if err := enc.EncodeInt32(int32(v.Priority)); err != nil {
	return fmt.Errorf("failed to encode Priority: %w", err)
}

	if err := enc.EncodeInt64(int64(v.Created)); err != nil {
	return fmt.Errorf("failed to encode Created: %w", err)
}

	if err := enc.EncodeBool(bool(v.Active)); err != nil {
	return fmt.Errorf("failed to encode Active: %w", err)
}

	if err := enc.EncodeFixedBytes(v.Hash[:]); err != nil {
	return fmt.Errorf("failed to encode Hash: %w", err)
}

	return nil
}
func (v *TestUser) Decode(dec *xdr.Decoder) error {

	
IDTmp, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode ID: %w", err)
}
v.ID = TestUserID(IDTmp)

	
SessionTmp, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Session: %w", err)
}
v.Session = TestSessionID(SessionTmp)

	
StatusTmp, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Status: %w", err)
}
v.Status = TestStatusCode(StatusTmp)

	
FlagsTmp, err := dec.DecodeUint64()
if err != nil {
	return fmt.Errorf("failed to decode Flags: %w", err)
}
v.Flags = TestFlags(FlagsTmp)

	
PriorityTmp, err := dec.DecodeInt32()
if err != nil {
	return fmt.Errorf("failed to decode Priority: %w", err)
}
v.Priority = TestPriority(PriorityTmp)

	
CreatedTmp, err := dec.DecodeInt64()
if err != nil {
	return fmt.Errorf("failed to decode Created: %w", err)
}
v.Created = TestTimestamp(CreatedTmp)

	
ActiveTmp, err := dec.DecodeBool()
if err != nil {
	return fmt.Errorf("failed to decode Active: %w", err)
}
v.Active = TestIsActive(ActiveTmp)

	
if err := dec.DecodeFixedBytesInto(v.Hash[:]); err != nil {
	return fmt.Errorf("failed to decode Hash: %w", err)
}

	return nil
}
var _ xdr.Codec = (*TestUser)(nil)

func (v *TestCrossFileReference) Encode(enc *xdr.Encoder) error {

	if err := v.CrossFileData.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode CrossFileData: %w", err)
	}


	if err := enc.EncodeUint32(uint32(len(v.Items))); err != nil {
		return fmt.Errorf("failed to encode Items length: %w", err)
	}
for _, elem := range v.Items {
	
	if err := elem.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode element: %w", err)
	}
	
	}

	return nil
}
func (v *TestCrossFileReference) Decode(dec *xdr.Decoder) error {

	if err := v.CrossFileData.Decode(dec); err != nil {
		return fmt.Errorf("failed to decode CrossFileData: %w", err)
	}


	ItemsLen, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Items length: %w", err)
	}
v.Items = make([]CrossFileStruct, ItemsLen)
for i := range v.Items {
	
	if err := v.Items[i].Decode(dec); err != nil {
		return fmt.Errorf("failed to decode element: %w", err)
	}
	
	}

	return nil
}
var _ xdr.Codec = (*TestCrossFileReference)(nil)

