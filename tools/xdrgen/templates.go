package main

import (
	"fmt"
	"strings"
	"text/template"
	"time"
)

// FileData represents data for file header templates
type FileData struct {
	SourceFile      string
	Timestamp       string
	PackageName     string
	ExternalImports []string
	Types           []TypeData
	BuildTags       []string
}

// TypeData represents data for type templates
type TypeData struct {
	TypeName string
	Fields   []FieldData
}

// FieldData represents data for field templates
type FieldData struct {
	FieldName         string
	FieldType         string
	ElementType       string
	EncodeCode        string
	DecodeCode        string
	Method            string
	VarName           string
	DiscriminantField string
	Cases             []UnionCaseData
	HasDefaultCase    bool
	ElementEncodeCode string
	ElementDecodeCode string
	// Alias-specific fields
	UnderlyingType string
	AliasType      string
	EncodeMethod   string
	DecodeMethod   string
}

// UnionCaseData represents data for union case templates
type UnionCaseData struct {
	CaseLabels string
	EncodeCode string
	DecodeCode string
	IsVoid     bool
}

// TemplateManager manages Go templates for code generation
type TemplateManager struct {
	templates map[string]*template.Template
}

// CodeGenerator handles XDR code generation with embedded template manager
// Add structTypes field to hold set of struct type names
type CodeGenerator struct {
	tm          *TemplateManager
	structTypes map[string]bool
}

// NewCodeGenerator creates a new code generator with initialized templates
// Accepts a list of struct type names
func NewCodeGenerator(structTypeNames []string) (*CodeGenerator, error) {
	tm, err := NewTemplateManager()
	if err != nil {
		return nil, err
	}
	structTypes := make(map[string]bool)
	for _, name := range structTypeNames {
		structTypes[name] = true
	}
	return &CodeGenerator{tm: tm, structTypes: structTypes}, nil
}

// NewTemplateManager creates a new template manager with all required templates
func NewTemplateManager() (*TemplateManager, error) {
	templates := make(map[string]*template.Template)

	// Define template functions
	funcMap := template.FuncMap{
		"toLowerCase": strings.ToLower,
		"trimPrefix":  strings.TrimPrefix,
		"hasPrefix":   strings.HasPrefix,
		"hasSuffix":   strings.HasSuffix,
		"ne":          func(a, b string) bool { return a != b },
	}

	// Template definitions
	templateDefs := map[string]string{
		"file_header": `// Code generated by xdrgen. DO NOT EDIT.
// Source: {{.SourceFile}}
// Generated: {{.Timestamp}}

package {{.PackageName}}

{{if .BuildTags}}
{{range .BuildTags}}
{{.}}
{{end}}
{{end}}

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
	{{range .ExternalImports}}
	"{{.}}"
	{{end}}
)
`,

		"encode_method": `func (v *{{.TypeName}}) Encode(enc *xdr.Encoder) error {
	{{range .Fields}}
	{{.EncodeCode}}
	{{end}}
	return nil
}
`,

		"decode_method": `func (v *{{.TypeName}}) Decode(dec *xdr.Decoder) error {
	{{range .Fields}}
	{{.DecodeCode}}
	{{end}}
	return nil
}
`,

		"assertion": `var _ xdr.Codec = (*{{.TypeName}})(nil)
`,

		"field_encode_basic": `if err := enc.{{.Method}}(v.{{.FieldName}}); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}}: %w", err)
}`,

		"field_decode_basic": `{{.VarName}}, err := dec.{{.Method}}()
if err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}}: %w", err)
}
v.{{.FieldName}} = {{.VarName}}`,

		"field_encode_struct": `if err := v.{{.FieldName}}.Encode(enc); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}}: %w", err)
}`,

		"field_decode_struct": `if err := v.{{.FieldName}}.Decode(dec); err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}}: %w", err)
}`,

		"array_encode": `if err := enc.EncodeUint32(uint32(len(v.{{.FieldName}}))); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}} length: %w", err)
}
for i := range v.{{.FieldName}} {
	{{.ElementEncodeCode}}
}`,

		"array_decode": `{{.FieldName}}Len, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}} length: %w", err)
}
v.{{.FieldName}} = make([]{{.ElementType}}, {{.FieldName}}Len)
for i := range v.{{.FieldName}} {
	{{.ElementDecodeCode}}
}`,

		"field_encode_alias": `if err := enc.{{.EncodeMethod}}({{.UnderlyingType}}(v.{{.FieldName}})); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}}: %w", err)
}`,

		"field_decode_alias": `var {{.FieldName}}Raw {{.UnderlyingType}}
if err := dec.{{.DecodeMethod}}(&{{.FieldName}}Raw); err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}}: %w", err)
}
v.{{.FieldName}} = {{.AliasType}}({{.FieldName}}Raw)`,

		"union_encode": `switch v.{{.DiscriminantField}} {
{{range .Cases}}
{{.CaseLabels}}:
	{{.EncodeCode}}
{{end}}
default:
	return fmt.Errorf("unsupported {{.DiscriminantField}} value: %v", v.{{.DiscriminantField}})
}`,

		"union_decode": `switch v.{{.DiscriminantField}} {
{{range .Cases}}
{{.CaseLabels}}:
	{{.DecodeCode}}
{{end}}
default:
	return fmt.Errorf("unsupported {{.DiscriminantField}} value: %v", v.{{.DiscriminantField}})
}`,

		"union_case_bytes_encode": `if err := enc.EncodeBytes(v.{{.FieldName}}); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}}: %w", err)
}`,

		"union_case_struct_encode": `if err := v.{{.FieldName}}.Encode(enc); err != nil {
	return fmt.Errorf("failed to encode {{.FieldName}}: %w", err)
}`,

		"union_case_bytes_decode": `data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}}: %w", err)
}
v.{{.FieldName}} = data`,

		"union_case_struct_decode": `v.{{.FieldName}} = &{{.FieldType}}{}
if err := v.{{.FieldName}}.Decode(dec); err != nil {
	return fmt.Errorf("failed to decode {{.FieldName}}: %w", err)
}`,

		"union_case_void": `// Void case - no data to encode/decode`,

		"array_element_encode": `{{.ElementEncodeCode}}`,

		"array_element_decode": `{{.ElementDecodeCode}}`,
	}

	// Parse all templates
	for name, content := range templateDefs {
		tmpl, err := template.New(name).Funcs(funcMap).Parse(content)
		if err != nil {
			return nil, fmt.Errorf("failed to parse template %s: %w", name, err)
		}
		templates[name] = tmpl
	}

	return &TemplateManager{templates: templates}, nil
}

// GetTemplate returns a template by name
func (tm *TemplateManager) GetTemplate(name string) (*template.Template, bool) {
	tmpl, exists := tm.templates[name]
	return tmpl, exists
}

// ExecuteTemplate executes a template with the given data
func (tm *TemplateManager) ExecuteTemplate(name string, data any) (string, error) {
	tmpl, exists := tm.GetTemplate(name)
	if !exists {
		return "", fmt.Errorf("template %s not found", name)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template %s: %w", name, err)
	}

	return buf.String(), nil
}

// Template-based code generation functions

// GenerateFileHeader generates the file header using templates
func (cg *CodeGenerator) GenerateFileHeader(sourceFile, packageName string, externalImports []string, buildTags []string) (string, error) {
	data := FileData{
		SourceFile:      sourceFile,
		Timestamp:       time.Now().Format(time.RFC3339),
		PackageName:     packageName,
		ExternalImports: externalImports,
		BuildTags:       buildTags,
	}
	return cg.tm.ExecuteTemplate("file_header", data)
}

// GenerateEncodeMethod generates the encode method using templates
func (cg *CodeGenerator) GenerateEncodeMethod(typeInfo TypeInfo) (string, error) {
	// Convert fields to template data
	var fields []FieldData
	for _, field := range typeInfo.Fields {
		fieldData := FieldData{
			FieldName: field.Name,
			FieldType: field.Type,
		}

		// Generate field-specific encode code
		if field.IsUnion {
			// Union field
			encodeCode, err := cg.generateUnionEncodeCode(field, typeInfo)
			if err != nil {
				return "", err
			}
			fieldData.EncodeCode = encodeCode
		} else if field.IsKey {
			// Key field
			encodeCode, err := cg.generateBasicEncodeCode(field)
			if err != nil {
				return "", err
			}
			fieldData.EncodeCode = encodeCode
		} else {
			// Regular field
			encodeCode, err := cg.generateBasicEncodeCode(field)
			if err != nil {
				return "", err
			}
			fieldData.EncodeCode = encodeCode
		}

		fields = append(fields, fieldData)
	}

	data := TypeData{
		TypeName: typeInfo.Name,
		Fields:   fields,
	}
	return cg.tm.ExecuteTemplate("encode_method", data)
}

// GenerateDecodeMethod generates the decode method using templates
func (cg *CodeGenerator) GenerateDecodeMethod(typeInfo TypeInfo) (string, error) {
	// Convert fields to template data
	var fields []FieldData
	for _, field := range typeInfo.Fields {
		fieldData := FieldData{
			FieldName: field.Name,
			FieldType: field.Type,
		}

		// Generate field-specific decode code
		if field.IsUnion {
			// Union field
			decodeCode, err := cg.generateUnionDecodeCode(field, typeInfo)
			if err != nil {
				return "", err
			}
			fieldData.DecodeCode = decodeCode
		} else if field.IsKey {
			// Key field
			decodeCode, err := cg.generateBasicDecodeCode(field)
			if err != nil {
				return "", err
			}
			fieldData.DecodeCode = decodeCode
		} else {
			// Regular field
			decodeCode, err := cg.generateBasicDecodeCode(field)
			if err != nil {
				return "", err
			}
			fieldData.DecodeCode = decodeCode
		}

		fields = append(fields, fieldData)
	}

	data := TypeData{
		TypeName: typeInfo.Name,
		Fields:   fields,
	}
	return cg.tm.ExecuteTemplate("decode_method", data)
}

// GenerateAssertion generates the compile-time assertion using templates
func (cg *CodeGenerator) GenerateAssertion(typeName string) (string, error) {
	data := TypeData{
		TypeName: typeName,
	}
	return cg.tm.ExecuteTemplate("assertion", data)
}

// Helper functions for generating field-specific code

// generateBasicEncodeCode generates basic encode code for a field
func (cg *CodeGenerator) generateBasicEncodeCode(field FieldInfo) (string, error) {
	// Handle struct types specially
	if field.XDRType == "struct" {
		data := FieldData{
			FieldName: field.Name,
		}
		return cg.tm.ExecuteTemplate("field_encode_struct", data)
	}

	// Handle array types specially
	if field.XDRType == "array" {
		elementType := strings.TrimPrefix(field.Type, "[]")

		// Create a temporary field info for the element type
		elementField := FieldInfo{
			Name:    "element",
			Type:    elementType,
			XDRType: elementType, // Use the element type as XDR type
		}

		// For struct types, set XDR type to "struct" dynamically
		if cg.structTypes[elementType] {
			elementField.XDRType = "struct"
		}

		// Generate element encode code using the template system
		elementEncodeCode, err := cg.generateBasicEncodeCode(elementField)
		if err != nil {
			return "", fmt.Errorf("failed to generate element encode code for %s: %w", field.Name, err)
		}

		// Replace field references with array element references
		elementEncodeCode = strings.ReplaceAll(elementEncodeCode, "v.element", fmt.Sprintf("v.%s[i]", field.Name))
		elementEncodeCode = strings.ReplaceAll(elementEncodeCode, "element", fmt.Sprintf("%s[i]", field.Name))

		// Use the array element template to wrap the element code
		elementData := FieldData{
			FieldName:         field.Name,
			ElementEncodeCode: elementEncodeCode,
		}
		elementEncodeCode, err = cg.tm.ExecuteTemplate("array_element_encode", elementData)
		if err != nil {
			return "", fmt.Errorf("failed to generate array element encode template for %s: %w", field.Name, err)
		}

		data := FieldData{
			FieldName:         field.Name,
			FieldType:         field.Type,
			ElementType:       elementType,
			ElementEncodeCode: elementEncodeCode,
		}
		return cg.tm.ExecuteTemplate("array_encode", data)
	}

	// Handle alias types specially
	if strings.HasPrefix(field.XDRType, "alias:") {
		// Extract the underlying type from the alias specification
		underlyingType := strings.TrimPrefix(field.XDRType, "alias:")
		if underlyingType == "[]byte" {
			underlyingType = "bytes"
		}
		// Handle fixed-size byte arrays like [16]byte
		if strings.HasPrefix(underlyingType, "[") && strings.HasSuffix(underlyingType, "]byte") {
			size := strings.TrimSuffix(strings.TrimPrefix(underlyingType, "["), "]byte")
			underlyingType = "fixed:" + size
		}
		encodeMethod := cg.getEncodeMethod(underlyingType)
		if encodeMethod == "" {
			return "", fmt.Errorf("unsupported underlying type for alias: %s", underlyingType)
		}

		// Handle fixed-size byte arrays specially
		if strings.HasPrefix(underlyingType, "fixed:") {
			return fmt.Sprintf(`if err := enc.EncodeFixedBytes(v.%s[:]); err != nil {
	return fmt.Errorf("failed to encode %s: %%w", err)
}`, field.Name, field.Name), nil
		}

		data := FieldData{
			FieldName:      field.Name,
			UnderlyingType: goTypeForXDRType(underlyingType),
			EncodeMethod:   encodeMethod,
		}
		return cg.tm.ExecuteTemplate("field_encode_alias", data)
	}

	method := cg.getEncodeMethod(field.XDRType)
	if method == "" {
		return "", fmt.Errorf("unsupported XDR type for encoding: %s", field.XDRType)
	}

	data := FieldData{
		FieldName: field.Name,
		Method:    method,
	}
	return cg.tm.ExecuteTemplate("field_encode_basic", data)
}

// generateBasicDecodeCode generates basic decode code for a field
func (cg *CodeGenerator) generateBasicDecodeCode(field FieldInfo) (string, error) {
	// Handle struct types specially
	if field.XDRType == "struct" {
		data := FieldData{
			FieldName: field.Name,
		}
		return cg.tm.ExecuteTemplate("field_decode_struct", data)
	}

	// Handle array types specially
	if field.XDRType == "array" {
		elementType := strings.TrimPrefix(field.Type, "[]")

		// Create a temporary field info for the element type
		elementField := FieldInfo{
			Name:    "element",
			Type:    elementType,
			XDRType: elementType, // Use the element type as XDR type
		}

		// For struct types, set XDR type to "struct" dynamically
		if cg.structTypes[elementType] {
			elementField.XDRType = "struct"
		}

		// Generate element decode code using the template system
		elementDecodeCode, err := cg.generateBasicDecodeCode(elementField)
		if err != nil {
			return "", fmt.Errorf("failed to generate element decode code for %s: %w", field.Name, err)
		}

		// Replace field references with array element references
		elementDecodeCode = strings.ReplaceAll(elementDecodeCode, "v.element", fmt.Sprintf("v.%s[i]", field.Name))
		elementDecodeCode = strings.ReplaceAll(elementDecodeCode, "tempelement", "temp")
		elementDecodeCode = strings.ReplaceAll(elementDecodeCode, "element", fmt.Sprintf("%s[i]", field.Name))

		// Use the array element template to wrap the element code
		elementData := FieldData{
			FieldName:         field.Name,
			ElementDecodeCode: elementDecodeCode,
		}
		elementDecodeCode, err = cg.tm.ExecuteTemplate("array_element_decode", elementData)
		if err != nil {
			return "", fmt.Errorf("failed to generate array element decode template for %s: %w", field.Name, err)
		}

		data := FieldData{
			FieldName:         field.Name,
			FieldType:         field.Type,
			ElementType:       elementType,
			ElementDecodeCode: elementDecodeCode,
		}
		return cg.tm.ExecuteTemplate("array_decode", data)
	}

	// Handle alias types specially
	if strings.HasPrefix(field.XDRType, "alias:") {
		// Extract the underlying type from the alias specification
		underlyingType := strings.TrimPrefix(field.XDRType, "alias:")
		if underlyingType == "[]byte" {
			underlyingType = "bytes"
		}
		// Handle fixed-size byte arrays like [16]byte
		if strings.HasPrefix(underlyingType, "[") && strings.HasSuffix(underlyingType, "]byte") {
			size := strings.TrimSuffix(strings.TrimPrefix(underlyingType, "["), "]byte")
			underlyingType = "fixed:" + size
		}
		decodeMethod := cg.getDecodeMethod(underlyingType)
		if decodeMethod == "" {
			return "", fmt.Errorf("unsupported underlying type for alias: %s", underlyingType)
		}

		// Handle fixed-size byte arrays specially
		if strings.HasPrefix(underlyingType, "fixed:") {
			data := FieldData{
				FieldName:      field.Name,
				UnderlyingType: goTypeForXDRType(underlyingType),
				AliasType:      field.Type,
				DecodeMethod:   decodeMethod,
			}
			return cg.tm.ExecuteTemplate("field_decode_alias", data)
		}

		data := FieldData{
			FieldName:      field.Name,
			UnderlyingType: goTypeForXDRType(underlyingType),
			AliasType:      field.Type,
			DecodeMethod:   decodeMethod,
		}
		return cg.tm.ExecuteTemplate("field_decode_alias", data)
	}

	method := cg.getDecodeMethod(field.XDRType)
	if method == "" {
		return "", fmt.Errorf("unsupported XDR type for decoding: %s", field.XDRType)
	}

	data := FieldData{
		FieldName: field.Name,
		FieldType: field.Type,
		Method:    method,
		VarName:   "temp" + field.Name,
	}
	return cg.tm.ExecuteTemplate("field_decode_basic", data)
}

// generateUnionEncodeCode generates union encode code for a field
func (cg *CodeGenerator) generateUnionEncodeCode(field FieldInfo, structInfo TypeInfo) (string, error) {
	keyField := findKeyField(structInfo)
	if keyField == "" {
		return "", fmt.Errorf("no key field found for union field %s", field.Name)
	}

	if structInfo.UnionConfig == nil {
		return "", fmt.Errorf("no union configuration found for struct %s", structInfo.Name)
	}

	var templateCases []UnionCaseData

	// Generate cases for mapped constants
	for constantValue := range structInfo.UnionConfig.Cases {
		var encodeCode string
		var err error

		// Generate appropriate encode code based on field type
		if field.Type == "[]byte" {
			encodeCode, err = cg.tm.ExecuteTemplate("union_case_bytes_encode", FieldData{
				FieldName: field.Name,
			})
		} else {
			encodeCode, err = cg.tm.ExecuteTemplate("union_case_struct_encode", FieldData{
				FieldName: field.Name,
			})
		}

		if err != nil {
			return "", err
		}

		templateCases = append(templateCases, UnionCaseData{
			CaseLabels: "case " + constantValue,
			EncodeCode: encodeCode,
			IsVoid:     false,
		})
	}

	// Generate void cases
	for _, voidCase := range structInfo.UnionConfig.VoidCases {
		encodeCode, err := cg.tm.ExecuteTemplate("union_case_void", nil)
		if err != nil {
			return "", err
		}

		templateCases = append(templateCases, UnionCaseData{
			CaseLabels: "case " + voidCase,
			EncodeCode: encodeCode,
			IsVoid:     true,
		})
	}

	data := FieldData{
		FieldName:         field.Name,
		DiscriminantField: keyField,
		Cases:             templateCases,
	}
	return cg.tm.ExecuteTemplate("union_encode", data)
}

// generateUnionDecodeCode generates union decode code for a field
func (cg *CodeGenerator) generateUnionDecodeCode(field FieldInfo, structInfo TypeInfo) (string, error) {
	keyField := findKeyField(structInfo)
	if keyField == "" {
		return "", fmt.Errorf("no key field found for union field %s", field.Name)
	}

	if structInfo.UnionConfig == nil {
		return "", fmt.Errorf("no union configuration found for struct %s", structInfo.Name)
	}

	var templateCases []UnionCaseData

	// Generate cases for mapped constants
	for constantValue := range structInfo.UnionConfig.Cases {
		var decodeCode string
		var err error

		// Generate appropriate decode code based on field type
		if field.Type == "[]byte" {
			decodeCode, err = cg.tm.ExecuteTemplate("union_case_bytes_decode", FieldData{
				FieldName: field.Name,
			})
		} else {
			decodeCode, err = cg.tm.ExecuteTemplate("union_case_struct_decode", FieldData{
				FieldName: field.Name,
				FieldType: strings.TrimPrefix(field.Type, "*"),
			})
		}

		if err != nil {
			return "", err
		}

		templateCases = append(templateCases, UnionCaseData{
			CaseLabels: "case " + constantValue,
			DecodeCode: decodeCode,
			IsVoid:     false,
		})
	}

	// Generate void cases
	for _, voidCase := range structInfo.UnionConfig.VoidCases {
		decodeCode, err := cg.tm.ExecuteTemplate("union_case_void", nil)
		if err != nil {
			return "", err
		}

		templateCases = append(templateCases, UnionCaseData{
			CaseLabels: "case " + voidCase,
			DecodeCode: decodeCode,
			IsVoid:     true,
		})
	}

	data := FieldData{
		FieldName:         field.Name,
		DiscriminantField: keyField,
		Cases:             templateCases,
	}
	return cg.tm.ExecuteTemplate("union_decode", data)
}

// getEncodeMethod returns the appropriate encoder method for an XDR type
func (cg *CodeGenerator) getEncodeMethod(xdrType string) string {
	switch xdrType {
	case "uint32":
		return "EncodeUint32"
	case "uint64":
		return "EncodeUint64"
	case "int32":
		return "EncodeInt32"
	case "int64":
		return "EncodeInt64"
	case "string":
		return "EncodeString"
	case "bytes":
		return "EncodeBytes"
	case "bool":
		return "EncodeBool"
	case "struct":
		return "Encode" // Delegate to struct's Encode method
	default:
		// Handle fixed-size byte arrays
		if strings.HasPrefix(xdrType, "fixed:") {
			return "EncodeFixedBytes"
		}
		// Check if this is a struct type
		if cg.structTypes[xdrType] {
			return "Encode"
		}
		return ""
	}
}

// goTypeForXDRType converts XDR type names to Go type names
func goTypeForXDRType(xdrType string) string {
	switch xdrType {
	case "string":
		return "string"
	case "bytes":
		return "[]byte"
	case "uint32":
		return "uint32"
	case "uint64":
		return "uint64"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "bool":
		return "bool"
	default:
		// Handle fixed-size byte arrays
		if strings.HasPrefix(xdrType, "fixed:") {
			size := strings.TrimPrefix(xdrType, "fixed:")
			return "[" + size + "]byte"
		}
		panic("unsupported alias type: " + xdrType)
	}
}

// getDecodeMethod returns the appropriate decoder method for an XDR type
func (cg *CodeGenerator) getDecodeMethod(xdrType string) string {
	switch xdrType {
	case "uint32":
		return "DecodeUint32"
	case "uint64":
		return "DecodeUint64"
	case "int32":
		return "DecodeInt32"
	case "int64":
		return "DecodeInt64"
	case "string":
		return "DecodeString"
	case "bytes":
		return "DecodeBytes"
	case "bool":
		return "DecodeBool"
	case "struct":
		return "Decode" // Delegate to struct's Decode method
	default:
		// Handle fixed-size byte arrays
		if strings.HasPrefix(xdrType, "fixed:") {
			return "DecodeFixedBytes"
		}
		// Check if this is a struct type
		if cg.structTypes[xdrType] {
			return "Decode"
		}
		return ""
	}
}

// Array element generation is now handled directly in the complete array templates
