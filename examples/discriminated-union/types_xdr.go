// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/examples/discriminated-union/types.go
// Generated: 2025-07-20T11:39:51-07:00

package main

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
)

func (v *OperationResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
		return fmt.Errorf("failed to encode Status: %w", err)
	}

	// Switch based on key for union field Data
	switch v.Status {

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *OperationResult) Decode(dec *xdr.Decoder) error {

	tempStatus, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Status: %w", err)
	}
	v.Status = Status(tempStatus)

	// Switch based on key for union field Data
	switch v.Status {

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*OperationResult)(nil)

func (v *OpSuccessResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Message); err != nil {
		return fmt.Errorf("failed to encode Message: %w", err)
	}

	return nil
}
func (v *OpSuccessResult) Decode(dec *xdr.Decoder) error {

	tempMessage, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Message: %w", err)
	}
	v.Message = tempMessage

	return nil
}

var _ xdr.Codec = (*OpSuccessResult)(nil)

func (v *NetworkMessage) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Type)); err != nil {
		return fmt.Errorf("failed to encode Type: %w", err)
	}

	// Switch based on key for union field Payload
	switch v.Type {

	case MessageTypeText:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	case MessageTypeBinary:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *NetworkMessage) Decode(dec *xdr.Decoder) error {

	tempType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Type: %w", err)
	}
	v.Type = MessageType(tempType)

	// Switch based on key for union field Payload
	switch v.Type {

	case MessageTypeText:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	case MessageTypeBinary:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*NetworkMessage)(nil)

func (v *TextPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Content); err != nil {
		return fmt.Errorf("failed to encode Content: %w", err)
	}

	if err := enc.EncodeString(v.Sender); err != nil {
		return fmt.Errorf("failed to encode Sender: %w", err)
	}

	return nil
}
func (v *TextPayload) Decode(dec *xdr.Decoder) error {

	tempContent, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Content: %w", err)
	}
	v.Content = tempContent

	tempSender, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Sender: %w", err)
	}
	v.Sender = tempSender

	return nil
}

// ToUnion converts TextPayload to NetworkMessage
func (p *TextPayload) ToUnion() (*NetworkMessage, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode TextPayload: %w", err)
	}
	data := enc.Bytes()

	return &NetworkMessage{
		Type:    MessageTypeText,
		Payload: data,
	}, nil
}

// EncodeToUnion encodes TextPayload directly to union format
func (p *TextPayload) EncodeToUnion(enc *xdr.Encoder) error {
	// Encode discriminant
	if err := enc.EncodeUint32(uint32(MessageTypeText)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*TextPayload)(nil)

func (v *BinaryPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeBytes(v.Data); err != nil {
		return fmt.Errorf("failed to encode Data: %w", err)
	}

	if err := enc.EncodeUint32(v.Checksum); err != nil {
		return fmt.Errorf("failed to encode Checksum: %w", err)
	}

	return nil
}
func (v *BinaryPayload) Decode(dec *xdr.Decoder) error {

	tempData, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Data: %w", err)
	}
	v.Data = tempData

	tempChecksum, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Checksum: %w", err)
	}
	v.Checksum = tempChecksum

	return nil
}

// ToUnion converts BinaryPayload to NetworkMessage
func (p *BinaryPayload) ToUnion() (*NetworkMessage, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode BinaryPayload: %w", err)
	}
	data := enc.Bytes()

	return &NetworkMessage{
		Type:    MessageTypeBinary,
		Payload: data,
	}, nil
}

// EncodeToUnion encodes BinaryPayload directly to union format
func (p *BinaryPayload) EncodeToUnion(enc *xdr.Encoder) error {
	// Encode discriminant
	if err := enc.EncodeUint32(uint32(MessageTypeBinary)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*BinaryPayload)(nil)

func (v *FileOperation) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.OpType)); err != nil {
		return fmt.Errorf("failed to encode OpType: %w", err)
	}

	// Switch based on key for union field Result
	switch v.OpType {

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *FileOperation) Decode(dec *xdr.Decoder) error {

	tempOpType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode OpType: %w", err)
	}
	v.OpType = OpType(tempOpType)

	// Switch based on key for union field Result
	switch v.OpType {

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*FileOperation)(nil)

func (v *ReadResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeBool(v.Success); err != nil {
		return fmt.Errorf("failed to encode Success: %w", err)
	}

	if err := enc.EncodeBytes(v.Data); err != nil {
		return fmt.Errorf("failed to encode Data: %w", err)
	}

	if err := enc.EncodeUint32(v.Size); err != nil {
		return fmt.Errorf("failed to encode Size: %w", err)
	}

	return nil
}
func (v *ReadResult) Decode(dec *xdr.Decoder) error {

	tempSuccess, err := dec.DecodeBool()
	if err != nil {
		return fmt.Errorf("failed to decode Success: %w", err)
	}
	v.Success = tempSuccess

	tempData, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Data: %w", err)
	}
	v.Data = tempData

	tempSize, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Size: %w", err)
	}
	v.Size = tempSize

	return nil
}

var _ xdr.Codec = (*ReadResult)(nil)
