// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/examples/discriminated-union/types.go
// Generated: 2025-07-12T15:15:23-07:00

package main



import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
	
)

func (v *OperationResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
	return fmt.Errorf("failed to encode Status: %w", err)
}
	
	switch v.Status {

case StatusSuccess:
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}

case StatusError:
	// Void case - no data to encode/decode

case StatusPending:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Status value: %v", v.Status)
}
	
	return nil
}

func (v *OperationResult) Decode(dec *xdr.Decoder) error {
	
	tempStatus, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Status: %w", err)
}
v.Status = Status(tempStatus)
	
	switch v.Status {

case StatusSuccess:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = data

case StatusError:
	// Void case - no data to encode/decode

case StatusPending:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Status value: %v", v.Status)
}
	
	return nil
}

var _ xdr.Codec = (*OperationResult)(nil)

func (v *OpSuccessResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Message); err != nil {
	return fmt.Errorf("failed to encode Message: %w", err)
}
	
	return nil
}

func (v *OpSuccessResult) Decode(dec *xdr.Decoder) error {
	
	tempMessage, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Message: %w", err)
}
v.Message = tempMessage
	
	return nil
}

var _ xdr.Codec = (*OpSuccessResult)(nil)

func (v *NetworkMessage) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.Type)); err != nil {
	return fmt.Errorf("failed to encode Type: %w", err)
}
	
	switch v.Type {

case MessageTypeBinary:
	if err := enc.EncodeBytes(v.Payload); err != nil {
	return fmt.Errorf("failed to encode Payload: %w", err)
}

case MessageTypeText:
	// Void case - no data to encode/decode

case MessageTypeVoid:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Type value: %v", v.Type)
}
	
	return nil
}

func (v *NetworkMessage) Decode(dec *xdr.Decoder) error {
	
	tempType, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Type: %w", err)
}
v.Type = MessageType(tempType)
	
	switch v.Type {

case MessageTypeBinary:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Payload: %w", err)
}
v.Payload = data

case MessageTypeText:
	// Void case - no data to encode/decode

case MessageTypeVoid:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Type value: %v", v.Type)
}
	
	return nil
}

var _ xdr.Codec = (*NetworkMessage)(nil)

func (v *TextPayload) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Content); err != nil {
	return fmt.Errorf("failed to encode Content: %w", err)
}
	
	if err := enc.EncodeString(v.Sender); err != nil {
	return fmt.Errorf("failed to encode Sender: %w", err)
}
	
	return nil
}

func (v *TextPayload) Decode(dec *xdr.Decoder) error {
	
	tempContent, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Content: %w", err)
}
v.Content = tempContent
	
	tempSender, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Sender: %w", err)
}
v.Sender = tempSender
	
	return nil
}

var _ xdr.Codec = (*TextPayload)(nil)

func (v *BinaryPayload) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}
	
	if err := enc.EncodeUint32(v.Checksum); err != nil {
	return fmt.Errorf("failed to encode Checksum: %w", err)
}
	
	return nil
}

func (v *BinaryPayload) Decode(dec *xdr.Decoder) error {
	
	tempData, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = tempData
	
	tempChecksum, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Checksum: %w", err)
}
v.Checksum = tempChecksum
	
	return nil
}

var _ xdr.Codec = (*BinaryPayload)(nil)

func (v *FileOperation) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.OpType)); err != nil {
	return fmt.Errorf("failed to encode OpType: %w", err)
}
	
	switch v.OpType {

case OpTypeRead:
	if err := enc.EncodeBytes(v.Result); err != nil {
	return fmt.Errorf("failed to encode Result: %w", err)
}

case OpTypeWrite:
	// Void case - no data to encode/decode

case OpTypeDelete:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported OpType value: %v", v.OpType)
}
	
	return nil
}

func (v *FileOperation) Decode(dec *xdr.Decoder) error {
	
	tempOpType, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode OpType: %w", err)
}
v.OpType = OpType(tempOpType)
	
	switch v.OpType {

case OpTypeRead:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Result: %w", err)
}
v.Result = data

case OpTypeWrite:
	// Void case - no data to encode/decode

case OpTypeDelete:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported OpType value: %v", v.OpType)
}
	
	return nil
}

var _ xdr.Codec = (*FileOperation)(nil)

func (v *ReadResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeBool(v.Success); err != nil {
	return fmt.Errorf("failed to encode Success: %w", err)
}
	
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}
	
	if err := enc.EncodeUint32(v.Size); err != nil {
	return fmt.Errorf("failed to encode Size: %w", err)
}
	
	return nil
}

func (v *ReadResult) Decode(dec *xdr.Decoder) error {
	
	tempSuccess, err := dec.DecodeBool()
if err != nil {
	return fmt.Errorf("failed to decode Success: %w", err)
}
v.Success = tempSuccess
	
	tempData, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = tempData
	
	tempSize, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Size: %w", err)
}
v.Size = tempSize
	
	return nil
}

var _ xdr.Codec = (*ReadResult)(nil)

