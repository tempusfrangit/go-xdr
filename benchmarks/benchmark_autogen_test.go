//go:generate ../xdrgen $GOFILE
//go:build bench
// +build bench

package xdr_bench

import (
	"testing"

	"github.com/tempusfrangit/go-xdr"
)

// +xdr:generate
type BenchmarkPerson struct {
	ID    uint32 // auto-detected as uint32
	Name  string // auto-detected as string
	Age   uint32 // auto-detected as uint32
	Email string // auto-detected as string
}

// +xdr:generate
type BenchmarkCompany struct {
	Name      string            // auto-detected as string
	Founded   uint32            // auto-detected as uint32
	CEO       BenchmarkPerson   // auto-detected as struct
	Employees []BenchmarkPerson // auto-detected as array
}

// +xdr:generate
type BenchmarkConfig struct {
	Host      string   // auto-detected as string
	Port      uint32   // auto-detected as uint32
	EnableTLS bool     // auto-detected as bool
	Timeout   uint64   // auto-detected as uint64
	Features  []string // auto-detected as array
	Metadata  []byte   // auto-detected as bytes
}

// Discriminated union constants
type BenchmarkStatus uint32

const (
	BenchmarkStatusSuccess BenchmarkStatus = 0
	BenchmarkStatusError   BenchmarkStatus = 1
	BenchmarkStatusPending BenchmarkStatus = 2
)

// +xdr:union,key=Status
type BenchmarkResult struct {
	Status BenchmarkStatus // discriminant
	Data   []byte          // auto-detected as union payload
}

// +xdr:payload,union=BenchmarkResult,discriminant=BenchmarkStatusSuccess
type BenchmarkSuccessResult struct {
	Message string // auto-detected as string
}

// Message type constants
type BenchmarkMsgType uint32

const (
	BenchmarkMsgText   BenchmarkMsgType = 1
	BenchmarkMsgBinary BenchmarkMsgType = 2
	BenchmarkMsgVoid   BenchmarkMsgType = 3
)

// +xdr:union,key=Type
type BenchmarkMessage struct {
	Type    BenchmarkMsgType // discriminant
	Payload []byte           // auto-detected as union payload
}

// +xdr:payload,union=BenchmarkMessage,discriminant=BenchmarkMsgText
type BenchmarkTextPayload struct {
	Content string // auto-detected as string
	Sender  string // auto-detected as string
}

// Operation type constants
type BenchmarkOpType uint32

const (
	BenchmarkOpRead   BenchmarkOpType = 1
	BenchmarkOpWrite  BenchmarkOpType = 2
	BenchmarkOpDelete BenchmarkOpType = 3
)

// +xdr:union,key=OpType
type BenchmarkOperation struct {
	OpType BenchmarkOpType // discriminant
	Data   []byte          // auto-detected as union payload
}

// +xdr:payload,union=BenchmarkOperation,discriminant=BenchmarkOpRead
type BenchmarkReadResult struct {
	Success bool   // auto-detected as bool
	Data    []byte // auto-detected as bytes
	Size    uint32 // auto-detected as uint32
}

// Test data for benchmarks
var (
	benchmarkPerson = BenchmarkPerson{
		ID:    12345,
		Name:  "John Doe",
		Age:   30,
		Email: "john.doe@example.com",
	}

	benchmarkCompany = BenchmarkCompany{
		Name:    "Tech Corp",
		Founded: 2010,
		CEO:     benchmarkPerson,
		Employees: []BenchmarkPerson{
			{ID: 1, Name: "Alice Smith", Age: 28, Email: "alice@techcorp.com"},
			{ID: 2, Name: "Bob Johnson", Age: 32, Email: "bob@techcorp.com"},
			{ID: 3, Name: "Carol Williams", Age: 26, Email: "carol@techcorp.com"},
		},
	}

	benchmarkConfig = BenchmarkConfig{
		Host:      "localhost",
		Port:      8080,
		EnableTLS: true,
		Timeout:   30000,
		Features:  []string{"auth", "logging", "metrics", "monitoring"},
		Metadata:  []byte("server-metadata-v1.0"),
	}

	benchmarkResultSuccess = BenchmarkResult{
		Status: BenchmarkStatusSuccess,
		Data:   []byte("operation completed successfully"),
	}

	benchmarkResultError = BenchmarkResult{
		Status: BenchmarkStatusError,
		Data:   nil,
	}

	benchmarkMessageText = BenchmarkMessage{
		Type:    BenchmarkMsgText,
		Payload: []byte("Hello, World!"),
	}

	benchmarkMessageVoid = BenchmarkMessage{
		Type:    BenchmarkMsgVoid,
		Payload: nil,
	}

	benchmarkOperationRead = BenchmarkOperation{
		OpType: BenchmarkOpRead,
		Data:   []byte("file content data"),
	}

	benchmarkOperationWrite = BenchmarkOperation{
		OpType: BenchmarkOpWrite,
		Data:   nil,
	}
)

// Benchmark functions for autogenerated code

func BenchmarkAutogenPerson(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkPerson.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkPerson.Encode(enc)
		data := enc.Bytes()

		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = person.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkPerson)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkPerson)
		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &person)
		}
	})
}

func BenchmarkAutogenCompany(b *testing.B) {
	buf := make([]byte, 2048)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkCompany.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkCompany.Encode(enc)
		data := enc.Bytes()

		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = company.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkCompany)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkCompany)
		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &company)
		}
	})
}

func BenchmarkAutogenConfig(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkConfig.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkConfig.Encode(enc)
		data := enc.Bytes()

		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = config.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkConfig)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkConfig)
		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &config)
		}
	})
}

func BenchmarkAutogenDiscriminatedUnion(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Result/Success/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkResultSuccess.Encode(enc)
		}
	})

	b.Run("Result/Success/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkResultSuccess.Encode(enc)
		data := enc.Bytes()

		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = result.Decode(dec)
		}
	})

	b.Run("Result/Error/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkResultError.Encode(enc)
		}
	})

	b.Run("Result/Error/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkResultError.Encode(enc)
		data := enc.Bytes()

		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = result.Decode(dec)
		}
	})

	b.Run("Message/Text/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkMessageText.Encode(enc)
		}
	})

	b.Run("Message/Text/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkMessageText.Encode(enc)
		data := enc.Bytes()

		var message BenchmarkMessage
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = message.Decode(dec)
		}
	})

	b.Run("Message/Void/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkMessageVoid.Encode(enc)
		}
	})

	b.Run("Message/Void/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkMessageVoid.Encode(enc)
		data := enc.Bytes()

		var message BenchmarkMessage
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = message.Decode(dec)
		}
	})

	b.Run("Operation/Read/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkOperationRead.Encode(enc)
		}
	})

	b.Run("Operation/Read/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkOperationRead.Encode(enc)
		data := enc.Bytes()

		var operation BenchmarkOperation
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = operation.Decode(dec)
		}
	})

	b.Run("Operation/Write/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkOperationWrite.Encode(enc)
		}
	})

	b.Run("Operation/Write/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkOperationWrite.Encode(enc)
		data := enc.Bytes()

		var operation BenchmarkOperation
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = operation.Decode(dec)
		}
	})
}

func BenchmarkAutogenMarshalUnmarshal(b *testing.B) {
	b.Run("Person/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkPerson)
		}
	})

	b.Run("Person/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkPerson)
		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &person)
		}
	})

	b.Run("Company/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkCompany)
		}
	})

	b.Run("Company/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkCompany)
		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &company)
		}
	})

	b.Run("Config/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkConfig)
		}
	})

	b.Run("Config/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkConfig)
		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &config)
		}
	})

	b.Run("Union/Success/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkResultSuccess)
		}
	})

	b.Run("Union/Success/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkResultSuccess)
		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &result)
		}
	})

	b.Run("Union/Void/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkResultError)
		}
	})

	b.Run("Union/Void/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkResultError)
		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &result)
		}
	})
}

// Cycle Detection Benchmark Types

// BenchmarkNode represents a node in a potentially circular data structure
// +xdr:generate
type BenchmarkNode struct {
	ID       uint32           // auto-detected as uint32
	Value    string           // auto-detected as string
	Children []*BenchmarkNode // Can create cycles
}

// BenchmarkFlexibleData contains a self-reference that creates cycles
// +xdr:generate
type BenchmarkFlexibleData struct {
	ID   uint32                 // auto-detected as uint32
	Next *BenchmarkFlexibleData // Self-reference - forces loop detection
}

// BenchmarkSimpleData has no potential for cycles (should get fast path)
// +xdr:generate
type BenchmarkSimpleData struct {
	ID    uint32 // auto-detected as uint32
	Name  string // auto-detected as string
	Count int64  // auto-detected as int64
}

// Test data for cycle detection benchmarks
var (
	benchmarkSimpleData = BenchmarkSimpleData{
		ID:    1,
		Name:  "benchmark test",
		Count: 12345,
	}

	benchmarkNode = BenchmarkNode{
		ID:    1,
		Value: "root node",
		Children: []*BenchmarkNode{
			{ID: 2, Value: "child1", Children: nil},
			{ID: 3, Value: "child2", Children: nil},
		},
	}

	benchmarkFlexibleData = BenchmarkFlexibleData{
		ID:   1,
		Next: &BenchmarkFlexibleData{ID: 2, Next: nil}, // Allocated but no cycle
	}
)

func BenchmarkCycleDetection(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("SimpleData/Encode", func(b *testing.B) {
		// Should use fast path (no cycle detection)
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkSimpleData.Encode(enc)
		}
	})

	b.Run("SimpleData/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkSimpleData.Encode(enc)
		data := enc.Bytes()

		var simple BenchmarkSimpleData
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = simple.Decode(dec)
		}
	})

	b.Run("Node/Encode", func(b *testing.B) {
		// Should use cycle detection (potential cycles from []*Node)
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkNode.Encode(enc)
		}
	})

	b.Run("Node/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkNode.Encode(enc)
		data := enc.Bytes()

		var node BenchmarkNode
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = node.Decode(dec)
		}
	})

	b.Run("FlexibleData/Encode", func(b *testing.B) {
		// Should use cycle detection (any field is implicitly cyclable)
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkFlexibleData.Encode(enc)
		}
	})

	b.Run("FlexibleData/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkFlexibleData.Encode(enc)
		data := enc.Bytes()

		var flex BenchmarkFlexibleData
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = flex.Decode(dec)
		}
	})
}

func BenchmarkCycleDetectionMarshal(b *testing.B) {
	b.Run("SimpleData/Marshal", func(b *testing.B) {
		// Fast path - no cycle detection
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkSimpleData)
		}
	})

	b.Run("SimpleData/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkSimpleData)
		var simple BenchmarkSimpleData
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &simple)
		}
	})

	b.Run("Node/Marshal", func(b *testing.B) {
		// With cycle detection
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkNode)
		}
	})

	b.Run("Node/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkNode)
		var node BenchmarkNode
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &node)
		}
	})

	b.Run("FlexibleData/Marshal", func(b *testing.B) {
		// With cycle detection
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkFlexibleData)
		}
	})

	b.Run("FlexibleData/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkFlexibleData)
		var flex BenchmarkFlexibleData
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &flex)
		}
	})
}
