//go:build bench
// +build bench

package xdr_bench

import (
	"testing"

	"github.com/tempusfrangit/go-xdr"
)

// BenchmarkPerson for testing basic struct auto-generation
type BenchmarkPerson struct {
	ID    uint32 `xdr:"uint32"`
	Name  string `xdr:"string"`
	Age   uint32 `xdr:"uint32"`
	Email string `xdr:"string"`
}

// BenchmarkCompany for testing nested struct and array auto-generation
type BenchmarkCompany struct {
	Name      string            `xdr:"string"`
	Founded   uint32            `xdr:"uint32"`
	CEO       BenchmarkPerson   `xdr:"struct"`
	Employees []BenchmarkPerson `xdr:"array"`
}

// BenchmarkConfig for testing mixed primitive types
type BenchmarkConfig struct {
	Host      string   `xdr:"string"`
	Port      uint32   `xdr:"uint32"`
	EnableTLS bool     `xdr:"bool"`
	Timeout   uint64   `xdr:"uint64"`
	Features  []string `xdr:"array"`
	Metadata  []byte   `xdr:"bytes"`
}

// Discriminated union constants
type BenchmarkStatus uint32

const (
	BenchmarkStatusSuccess BenchmarkStatus = 0
	BenchmarkStatusError   BenchmarkStatus = 1
	BenchmarkStatusPending BenchmarkStatus = 2
)

// BenchmarkResult for testing discriminated union performance
type BenchmarkResult struct {
	Status BenchmarkStatus `xdr:"key"`
	Data   []byte          `xdr:"union"`
}

//xdr:union=BenchmarkResult,case=BenchmarkStatusSuccess
type BenchmarkSuccessResult struct {
	Message string `xdr:"string"`
}

// Message type constants
type BenchmarkMsgType uint32

const (
	BenchmarkMsgText   BenchmarkMsgType = 1
	BenchmarkMsgBinary BenchmarkMsgType = 2
	BenchmarkMsgVoid   BenchmarkMsgType = 3
)

// BenchmarkMessage for testing multi-case discriminated union
type BenchmarkMessage struct {
	Type    BenchmarkMsgType `xdr:"key"`
	Payload []byte           `xdr:"union"`
}

//xdr:union=BenchmarkMessage,case=BenchmarkMsgText
type BenchmarkTextPayload struct {
	Content string `xdr:"string"`
	Sender  string `xdr:"string"`
}

// Operation type constants
type BenchmarkOpType uint32

const (
	BenchmarkOpRead   BenchmarkOpType = 1
	BenchmarkOpWrite  BenchmarkOpType = 2
	BenchmarkOpDelete BenchmarkOpType = 3
)

// BenchmarkOperation for testing complex discriminated union
type BenchmarkOperation struct {
	OpType BenchmarkOpType `xdr:"key"`
	Data   []byte          `xdr:"union"`
}

//xdr:union=BenchmarkOperation,case=BenchmarkOpRead
type BenchmarkReadResult struct {
	Success bool   `xdr:"bool"`
	Data    []byte `xdr:"bytes"`
	Size    uint32 `xdr:"uint32"`
}

// Test data for benchmarks
var (
	benchmarkPerson = BenchmarkPerson{
		ID:    12345,
		Name:  "John Doe",
		Age:   30,
		Email: "john.doe@example.com",
	}

	benchmarkCompany = BenchmarkCompany{
		Name:    "Tech Corp",
		Founded: 2010,
		CEO:     benchmarkPerson,
		Employees: []BenchmarkPerson{
			{ID: 1, Name: "Alice Smith", Age: 28, Email: "alice@techcorp.com"},
			{ID: 2, Name: "Bob Johnson", Age: 32, Email: "bob@techcorp.com"},
			{ID: 3, Name: "Carol Williams", Age: 26, Email: "carol@techcorp.com"},
		},
	}

	benchmarkConfig = BenchmarkConfig{
		Host:      "localhost",
		Port:      8080,
		EnableTLS: true,
		Timeout:   30000,
		Features:  []string{"auth", "logging", "metrics", "monitoring"},
		Metadata:  []byte("server-metadata-v1.0"),
	}

	benchmarkResultSuccess = BenchmarkResult{
		Status: BenchmarkStatusSuccess,
		Data:   []byte("operation completed successfully"),
	}

	benchmarkResultError = BenchmarkResult{
		Status: BenchmarkStatusError,
		Data:   nil,
	}

	benchmarkMessageText = BenchmarkMessage{
		Type:    BenchmarkMsgText,
		Payload: []byte("Hello, World!"),
	}

	benchmarkMessageVoid = BenchmarkMessage{
		Type:    BenchmarkMsgVoid,
		Payload: nil,
	}

	benchmarkOperationRead = BenchmarkOperation{
		OpType: BenchmarkOpRead,
		Data:   []byte("file content data"),
	}

	benchmarkOperationWrite = BenchmarkOperation{
		OpType: BenchmarkOpWrite,
		Data:   nil,
	}
)

// Benchmark functions for autogenerated code

func BenchmarkAutogenPerson(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkPerson.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkPerson.Encode(enc)
		data := enc.Bytes()

		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = person.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkPerson)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkPerson)
		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &person)
		}
	})
}

func BenchmarkAutogenCompany(b *testing.B) {
	buf := make([]byte, 2048)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkCompany.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkCompany.Encode(enc)
		data := enc.Bytes()

		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = company.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkCompany)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkCompany)
		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &company)
		}
	})
}

func BenchmarkAutogenConfig(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkConfig.Encode(enc)
		}
	})

	b.Run("Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkConfig.Encode(enc)
		data := enc.Bytes()

		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = config.Decode(dec)
		}
	})

	b.Run("Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkConfig)
		}
	})

	b.Run("Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkConfig)
		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &config)
		}
	})
}

func BenchmarkAutogenDiscriminatedUnion(b *testing.B) {
	buf := make([]byte, 1024)

	b.Run("Result/Success/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkResultSuccess.Encode(enc)
		}
	})

	b.Run("Result/Success/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkResultSuccess.Encode(enc)
		data := enc.Bytes()

		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = result.Decode(dec)
		}
	})

	b.Run("Result/Error/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkResultError.Encode(enc)
		}
	})

	b.Run("Result/Error/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkResultError.Encode(enc)
		data := enc.Bytes()

		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = result.Decode(dec)
		}
	})

	b.Run("Message/Text/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkMessageText.Encode(enc)
		}
	})

	b.Run("Message/Text/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkMessageText.Encode(enc)
		data := enc.Bytes()

		var message BenchmarkMessage
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = message.Decode(dec)
		}
	})

	b.Run("Message/Void/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkMessageVoid.Encode(enc)
		}
	})

	b.Run("Message/Void/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkMessageVoid.Encode(enc)
		data := enc.Bytes()

		var message BenchmarkMessage
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = message.Decode(dec)
		}
	})

	b.Run("Operation/Read/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkOperationRead.Encode(enc)
		}
	})

	b.Run("Operation/Read/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkOperationRead.Encode(enc)
		data := enc.Bytes()

		var operation BenchmarkOperation
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = operation.Decode(dec)
		}
	})

	b.Run("Operation/Write/Encode", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			enc := xdr.NewEncoder(buf)
			_ = benchmarkOperationWrite.Encode(enc)
		}
	})

	b.Run("Operation/Write/Decode", func(b *testing.B) {
		enc := xdr.NewEncoder(buf)
		_ = benchmarkOperationWrite.Encode(enc)
		data := enc.Bytes()

		var operation BenchmarkOperation
		for i := 0; i < b.N; i++ {
			dec := xdr.NewDecoder(data)
			_ = operation.Decode(dec)
		}
	})
}

func BenchmarkAutogenMarshalUnmarshal(b *testing.B) {
	b.Run("Person/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkPerson)
		}
	})

	b.Run("Person/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkPerson)
		var person BenchmarkPerson
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &person)
		}
	})

	b.Run("Company/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkCompany)
		}
	})

	b.Run("Company/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkCompany)
		var company BenchmarkCompany
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &company)
		}
	})

	b.Run("Config/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkConfig)
		}
	})

	b.Run("Config/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkConfig)
		var config BenchmarkConfig
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &config)
		}
	})

	b.Run("Union/Success/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkResultSuccess)
		}
	})

	b.Run("Union/Success/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkResultSuccess)
		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &result)
		}
	})

	b.Run("Union/Void/Marshal", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			_, _ = xdr.Marshal(&benchmarkResultError)
		}
	})

	b.Run("Union/Void/Unmarshal", func(b *testing.B) {
		data, _ := xdr.Marshal(&benchmarkResultError)
		var result BenchmarkResult
		for i := 0; i < b.N; i++ {
			_ = xdr.Unmarshal(data, &result)
		}
	})
}
