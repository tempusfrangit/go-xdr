
//go:build bench
// +build bench


// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/benchmarks/benchmark_autogen_test.go
// Generated: 2025-07-12T15:41:35-07:00

package xdr_bench

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
	
)

func (v *BenchmarkPerson) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(v.ID); err != nil {
	return fmt.Errorf("failed to encode ID: %w", err)
}
	
	if err := enc.EncodeString(v.Name); err != nil {
	return fmt.Errorf("failed to encode Name: %w", err)
}
	
	if err := enc.EncodeUint32(v.Age); err != nil {
	return fmt.Errorf("failed to encode Age: %w", err)
}
	
	if err := enc.EncodeString(v.Email); err != nil {
	return fmt.Errorf("failed to encode Email: %w", err)
}
	
	return nil
}

func (v *BenchmarkPerson) Decode(dec *xdr.Decoder) error {
	
	tempID, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode ID: %w", err)
}
v.ID = tempID
	
	tempName, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Name: %w", err)
}
v.Name = tempName
	
	tempAge, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Age: %w", err)
}
v.Age = tempAge
	
	tempEmail, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Email: %w", err)
}
v.Email = tempEmail
	
	return nil
}

var _ xdr.Codec = (*BenchmarkPerson)(nil)

func (v *BenchmarkCompany) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Name); err != nil {
	return fmt.Errorf("failed to encode Name: %w", err)
}
	
	if err := enc.EncodeUint32(v.Founded); err != nil {
	return fmt.Errorf("failed to encode Founded: %w", err)
}
	
	if err := v.CEO.Encode(enc); err != nil {
	return fmt.Errorf("failed to encode CEO: %w", err)
}
	
	if err := enc.EncodeUint32(uint32(len(v.Employees))); err != nil {
	return fmt.Errorf("failed to encode Employees length: %w", err)
}
for i := range v.Employees {
	if err := v.Employees[i].Encode(enc); err != nil {
	return fmt.Errorf("failed to encode Employees[i]: %w", err)
}
}
	
	return nil
}

func (v *BenchmarkCompany) Decode(dec *xdr.Decoder) error {
	
	tempName, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Name: %w", err)
}
v.Name = tempName
	
	tempFounded, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Founded: %w", err)
}
v.Founded = tempFounded
	
	if err := v.CEO.Decode(dec); err != nil {
	return fmt.Errorf("failed to decode CEO: %w", err)
}
	
	EmployeesLen, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Employees length: %w", err)
}
v.Employees = make([]BenchmarkPerson, EmployeesLen)
for i := range v.Employees {
	if err := v.Employees[i].Decode(dec); err != nil {
	return fmt.Errorf("failed to decode Employees[i]: %w", err)
}
}
	
	return nil
}

var _ xdr.Codec = (*BenchmarkCompany)(nil)

func (v *BenchmarkConfig) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Host); err != nil {
	return fmt.Errorf("failed to encode Host: %w", err)
}
	
	if err := enc.EncodeUint32(v.Port); err != nil {
	return fmt.Errorf("failed to encode Port: %w", err)
}
	
	if err := enc.EncodeBool(v.EnableTLS); err != nil {
	return fmt.Errorf("failed to encode EnableTLS: %w", err)
}
	
	if err := enc.EncodeUint64(v.Timeout); err != nil {
	return fmt.Errorf("failed to encode Timeout: %w", err)
}
	
	if err := enc.EncodeUint32(uint32(len(v.Features))); err != nil {
	return fmt.Errorf("failed to encode Features length: %w", err)
}
for i := range v.Features {
	if err := enc.EncodeString(v.Features[i]); err != nil {
	return fmt.Errorf("failed to encode Features[i]: %w", err)
}
}
	
	if err := enc.EncodeBytes(v.Metadata); err != nil {
	return fmt.Errorf("failed to encode Metadata: %w", err)
}
	
	return nil
}

func (v *BenchmarkConfig) Decode(dec *xdr.Decoder) error {
	
	tempHost, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Host: %w", err)
}
v.Host = tempHost
	
	tempPort, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Port: %w", err)
}
v.Port = tempPort
	
	tempEnableTLS, err := dec.DecodeBool()
if err != nil {
	return fmt.Errorf("failed to decode EnableTLS: %w", err)
}
v.EnableTLS = tempEnableTLS
	
	tempTimeout, err := dec.DecodeUint64()
if err != nil {
	return fmt.Errorf("failed to decode Timeout: %w", err)
}
v.Timeout = tempTimeout
	
	FeaturesLen, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Features length: %w", err)
}
v.Features = make([]string, FeaturesLen)
for i := range v.Features {
	temp, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Features[i]: %w", err)
}
v.Features[i] = temp
}
	
	tempMetadata, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Metadata: %w", err)
}
v.Metadata = tempMetadata
	
	return nil
}

var _ xdr.Codec = (*BenchmarkConfig)(nil)

func (v *BenchmarkResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
	return fmt.Errorf("failed to encode Status: %w", err)
}
	
	switch v.Status {

case BenchmarkStatusSuccess:
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}

case BenchmarkStatusError:
	// Void case - no data to encode/decode

case BenchmarkStatusPending:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Status value: %v", v.Status)
}
	
	return nil
}

func (v *BenchmarkResult) Decode(dec *xdr.Decoder) error {
	
	tempStatus, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Status: %w", err)
}
v.Status = BenchmarkStatus(tempStatus)
	
	switch v.Status {

case BenchmarkStatusSuccess:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = data

case BenchmarkStatusError:
	// Void case - no data to encode/decode

case BenchmarkStatusPending:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Status value: %v", v.Status)
}
	
	return nil
}

var _ xdr.Codec = (*BenchmarkResult)(nil)

func (v *BenchmarkSuccessResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Message); err != nil {
	return fmt.Errorf("failed to encode Message: %w", err)
}
	
	return nil
}

func (v *BenchmarkSuccessResult) Decode(dec *xdr.Decoder) error {
	
	tempMessage, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Message: %w", err)
}
v.Message = tempMessage
	
	return nil
}

var _ xdr.Codec = (*BenchmarkSuccessResult)(nil)

func (v *BenchmarkMessage) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.Type)); err != nil {
	return fmt.Errorf("failed to encode Type: %w", err)
}
	
	switch v.Type {

case BenchmarkMsgText:
	if err := enc.EncodeBytes(v.Payload); err != nil {
	return fmt.Errorf("failed to encode Payload: %w", err)
}

case BenchmarkMsgBinary:
	// Void case - no data to encode/decode

case BenchmarkMsgVoid:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Type value: %v", v.Type)
}
	
	return nil
}

func (v *BenchmarkMessage) Decode(dec *xdr.Decoder) error {
	
	tempType, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Type: %w", err)
}
v.Type = BenchmarkMsgType(tempType)
	
	switch v.Type {

case BenchmarkMsgText:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Payload: %w", err)
}
v.Payload = data

case BenchmarkMsgBinary:
	// Void case - no data to encode/decode

case BenchmarkMsgVoid:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported Type value: %v", v.Type)
}
	
	return nil
}

var _ xdr.Codec = (*BenchmarkMessage)(nil)

func (v *BenchmarkTextPayload) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeString(v.Content); err != nil {
	return fmt.Errorf("failed to encode Content: %w", err)
}
	
	if err := enc.EncodeString(v.Sender); err != nil {
	return fmt.Errorf("failed to encode Sender: %w", err)
}
	
	return nil
}

func (v *BenchmarkTextPayload) Decode(dec *xdr.Decoder) error {
	
	tempContent, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Content: %w", err)
}
v.Content = tempContent
	
	tempSender, err := dec.DecodeString()
if err != nil {
	return fmt.Errorf("failed to decode Sender: %w", err)
}
v.Sender = tempSender
	
	return nil
}

var _ xdr.Codec = (*BenchmarkTextPayload)(nil)

func (v *BenchmarkOperation) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeUint32(uint32(v.OpType)); err != nil {
	return fmt.Errorf("failed to encode OpType: %w", err)
}
	
	switch v.OpType {

case BenchmarkOpRead:
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}

case BenchmarkOpWrite:
	// Void case - no data to encode/decode

case BenchmarkOpDelete:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported OpType value: %v", v.OpType)
}
	
	return nil
}

func (v *BenchmarkOperation) Decode(dec *xdr.Decoder) error {
	
	tempOpType, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode OpType: %w", err)
}
v.OpType = BenchmarkOpType(tempOpType)
	
	switch v.OpType {

case BenchmarkOpRead:
	data, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = data

case BenchmarkOpWrite:
	// Void case - no data to encode/decode

case BenchmarkOpDelete:
	// Void case - no data to encode/decode

default:
	return fmt.Errorf("unsupported OpType value: %v", v.OpType)
}
	
	return nil
}

var _ xdr.Codec = (*BenchmarkOperation)(nil)

func (v *BenchmarkReadResult) Encode(enc *xdr.Encoder) error {
	
	if err := enc.EncodeBool(v.Success); err != nil {
	return fmt.Errorf("failed to encode Success: %w", err)
}
	
	if err := enc.EncodeBytes(v.Data); err != nil {
	return fmt.Errorf("failed to encode Data: %w", err)
}
	
	if err := enc.EncodeUint32(v.Size); err != nil {
	return fmt.Errorf("failed to encode Size: %w", err)
}
	
	return nil
}

func (v *BenchmarkReadResult) Decode(dec *xdr.Decoder) error {
	
	tempSuccess, err := dec.DecodeBool()
if err != nil {
	return fmt.Errorf("failed to decode Success: %w", err)
}
v.Success = tempSuccess
	
	tempData, err := dec.DecodeBytes()
if err != nil {
	return fmt.Errorf("failed to decode Data: %w", err)
}
v.Data = tempData
	
	tempSize, err := dec.DecodeUint32()
if err != nil {
	return fmt.Errorf("failed to decode Size: %w", err)
}
v.Size = tempSize
	
	return nil
}

var _ xdr.Codec = (*BenchmarkReadResult)(nil)

