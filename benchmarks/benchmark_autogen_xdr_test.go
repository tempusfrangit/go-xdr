//go:build bench
// +build bench

// Code generated by go generate. DO NOT EDIT.
// Source: benchmark_autogen_test.go
// Generated at: 2025-07-11T09:34:49-07:00

package xdr_bench

import (
	"fmt"

	"github.com/tempusfrangit/go-xdr"
)

func (v *BenchmarkPerson) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.ID); err != nil {
		return fmt.Errorf("failed to encode ID: %w", err)
	}

	if err := enc.EncodeString(v.Name); err != nil {
		return fmt.Errorf("failed to encode Name: %w", err)
	}

	if err := enc.EncodeUint32(v.Age); err != nil {
		return fmt.Errorf("failed to encode Age: %w", err)
	}

	if err := enc.EncodeString(v.Email); err != nil {
		return fmt.Errorf("failed to encode Email: %w", err)
	}

	return nil
}
func (v *BenchmarkPerson) Decode(dec *xdr.Decoder) error {

	IDVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ID: %w", err)
	}
	v.ID = IDVal

	NameVal, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Name: %w", err)
	}
	v.Name = NameVal

	AgeVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Age: %w", err)
	}
	v.Age = AgeVal

	EmailVal, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Email: %w", err)
	}
	v.Email = EmailVal

	return nil
}
// Compile-time assertion that BenchmarkPerson implements xdr.Codec
var _ xdr.Codec = (*BenchmarkPerson)(nil)
func (v *BenchmarkCompany) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Name); err != nil {
		return fmt.Errorf("failed to encode Name: %w", err)
	}

	if err := enc.EncodeUint32(v.Founded); err != nil {
		return fmt.Errorf("failed to encode Founded: %w", err)
	}

	if err := v.CEO.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode CEO: %w", err)
	}

	if err := enc.EncodeUint32(uint32(len(v.Employees))); err != nil {
		return fmt.Errorf("failed to encode Employees length: %w", err)
	}
	for i, elem := range v.Employees {
		if err := elem.Encode(enc); err != nil {
			return fmt.Errorf("failed to encode array element %d: %w", i, err)
		}
	}

	return nil
}
func (v *BenchmarkCompany) Decode(dec *xdr.Decoder) error {

	NameVal, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Name: %w", err)
	}
	v.Name = NameVal

	FoundedVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Founded: %w", err)
	}
	v.Founded = FoundedVal

	if err := v.CEO.Decode(dec); err != nil {
		return fmt.Errorf("failed to decode CEO: %w", err)
	}

	length, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Employees length: %w", err)
	}
	v.Employees = make([]BenchmarkPerson, length)
	for i := uint32(0); i < length; i++ {
		if err := v.Employees[i].Decode(dec); err != nil {
			return fmt.Errorf("failed to decode array element %d: %w", i, err)
		}
	}

	return nil
}
// Compile-time assertion that BenchmarkCompany implements xdr.Codec
var _ xdr.Codec = (*BenchmarkCompany)(nil)
func (v *BenchmarkConfig) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Host); err != nil {
		return fmt.Errorf("failed to encode Host: %w", err)
	}

	if err := enc.EncodeUint32(v.Port); err != nil {
		return fmt.Errorf("failed to encode Port: %w", err)
	}

	if err := enc.EncodeBool(v.EnableTLS); err != nil {
		return fmt.Errorf("failed to encode EnableTLS: %w", err)
	}

	if err := enc.EncodeUint64(v.Timeout); err != nil {
		return fmt.Errorf("failed to encode Timeout: %w", err)
	}

	if err := enc.EncodeUint32(uint32(len(v.Features))); err != nil {
		return fmt.Errorf("failed to encode Features length: %w", err)
	}
	for i, elem := range v.Features {
		if err := enc.EncodeString(elem); err != nil {
			return fmt.Errorf("failed to encode array element %d: %w", i, err)
		}
	}

	if err := enc.EncodeBytes(v.Metadata); err != nil {
		return fmt.Errorf("failed to encode Metadata: %w", err)
	}

	return nil
}
func (v *BenchmarkConfig) Decode(dec *xdr.Decoder) error {

	HostVal, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Host: %w", err)
	}
	v.Host = HostVal

	PortVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Port: %w", err)
	}
	v.Port = PortVal

	EnableTLSVal, err := dec.DecodeBool()
	if err != nil {
		return fmt.Errorf("failed to decode EnableTLS: %w", err)
	}
	v.EnableTLS = EnableTLSVal

	TimeoutVal, err := dec.DecodeUint64()
	if err != nil {
		return fmt.Errorf("failed to decode Timeout: %w", err)
	}
	v.Timeout = TimeoutVal

	length, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Features length: %w", err)
	}
	v.Features = make([]string, length)
	for i := uint32(0); i < length; i++ {
		val, err := dec.DecodeString()
		if err != nil {
			return fmt.Errorf("failed to decode array element %d: %w", i, err)
		}
		v.Features[i] = val
	}

	MetadataVal, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Metadata: %w", err)
	}
	v.Metadata = MetadataVal

	return nil
}
// Compile-time assertion that BenchmarkConfig implements xdr.Codec
var _ xdr.Codec = (*BenchmarkConfig)(nil)
func (v *BenchmarkResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.Status); err != nil {
		return fmt.Errorf("failed to encode Status: %w", err)
	}

	// Switch based on discriminant for union field Data
	switch v.Status {

	case 0:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	default:
		// void case - no data


	}

	return nil
}
func (v *BenchmarkResult) Decode(dec *xdr.Decoder) error {

	StatusVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Status: %w", err)
	}
	v.Status = StatusVal

	// Switch based on discriminant for union field Data
	switch v.Status {

	case 0:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	default:
		// void case - no data


	}

	return nil
}
// Compile-time assertion that BenchmarkResult implements xdr.Codec
var _ xdr.Codec = (*BenchmarkResult)(nil)
func (v *BenchmarkMessage) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.Type); err != nil {
		return fmt.Errorf("failed to encode Type: %w", err)
	}

	// Switch based on discriminant for union field Payload
	switch v.Type {

	case 1:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	case 2:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	default:
		// void case - no data


	}

	return nil
}
func (v *BenchmarkMessage) Decode(dec *xdr.Decoder) error {

	TypeVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Type: %w", err)
	}
	v.Type = TypeVal

	// Switch based on discriminant for union field Payload
	switch v.Type {

	case 1:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	case 2:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	default:
		// void case - no data


	}

	return nil
}
// Compile-time assertion that BenchmarkMessage implements xdr.Codec
var _ xdr.Codec = (*BenchmarkMessage)(nil)
func (v *BenchmarkOperation) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.OpType); err != nil {
		return fmt.Errorf("failed to encode OpType: %w", err)
	}

	// Switch based on discriminant for union field Data
	switch v.OpType {

	case 1:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	case 2:
		// void case - no data

	case 3:
		// void case - no data


	default:
		// unknown discriminant - encode nothing

	}

	return nil
}
func (v *BenchmarkOperation) Decode(dec *xdr.Decoder) error {

	OpTypeVal, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode OpType: %w", err)
	}
	v.OpType = OpTypeVal

	// Switch based on discriminant for union field Data
	switch v.OpType {

	case 1:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	case 2:
		// void case - no data

	case 3:
		// void case - no data


	default:
		// unknown discriminant - decode nothing

	}

	return nil
}
// Compile-time assertion that BenchmarkOperation implements xdr.Codec
var _ xdr.Codec = (*BenchmarkOperation)(nil)
