
//go:build bench
// +build bench

// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/benchmarks/benchmark_autogen_test.go
// Generated: 2025-07-13T00:26:50-07:00

package xdr_bench

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"

)

func (v *BenchmarkPerson) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.ID); err != nil {
		return fmt.Errorf("failed to encode ID: %w", err)
	}

	if err := enc.EncodeString(v.Name); err != nil {
		return fmt.Errorf("failed to encode Name: %w", err)
	}

	if err := enc.EncodeUint32(v.Age); err != nil {
		return fmt.Errorf("failed to encode Age: %w", err)
	}

	if err := enc.EncodeString(v.Email); err != nil {
		return fmt.Errorf("failed to encode Email: %w", err)
	}

	return nil
}
func (v *BenchmarkPerson) Decode(dec *xdr.Decoder) error {

	tempID, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ID: %w", err)
	}
v.ID = tempID

	tempName, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Name: %w", err)
	}
v.Name = tempName

	tempAge, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Age: %w", err)
	}
v.Age = tempAge

	tempEmail, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Email: %w", err)
	}
v.Email = tempEmail

	return nil
}
var _ xdr.Codec = (*BenchmarkPerson)(nil)

func (v *BenchmarkCompany) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Name); err != nil {
		return fmt.Errorf("failed to encode Name: %w", err)
	}

	if err := enc.EncodeUint32(v.Founded); err != nil {
		return fmt.Errorf("failed to encode Founded: %w", err)
	}

	if err := v.CEO.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode CEO: %w", err)
	}


	if err := enc.EncodeUint32(uint32(len(v.Employees))); err != nil {
		return fmt.Errorf("failed to encode Employees length: %w", err)
	}
for _, elem := range v.Employees {
	
	if err := elem.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode element: %w", err)
	}
	
	}

	return nil
}
func (v *BenchmarkCompany) Decode(dec *xdr.Decoder) error {

	tempName, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Name: %w", err)
	}
v.Name = tempName

	tempFounded, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Founded: %w", err)
	}
v.Founded = tempFounded

	if err := v.CEO.Decode(dec); err != nil {
		return fmt.Errorf("failed to decode CEO: %w", err)
	}


	EmployeesLen, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Employees length: %w", err)
	}
v.Employees = make([]BenchmarkPerson, EmployeesLen)
for i := range v.Employees {
	
	if err := v.Employees[i].Decode(dec); err != nil {
		return fmt.Errorf("failed to decode element: %w", err)
	}
	
	}

	return nil
}
var _ xdr.Codec = (*BenchmarkCompany)(nil)

func (v *BenchmarkConfig) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Host); err != nil {
		return fmt.Errorf("failed to encode Host: %w", err)
	}

	if err := enc.EncodeUint32(v.Port); err != nil {
		return fmt.Errorf("failed to encode Port: %w", err)
	}

	if err := enc.EncodeBool(v.EnableTLS); err != nil {
		return fmt.Errorf("failed to encode EnableTLS: %w", err)
	}

	if err := enc.EncodeUint64(v.Timeout); err != nil {
		return fmt.Errorf("failed to encode Timeout: %w", err)
	}

	if err := enc.EncodeUint32(uint32(len(v.Features))); err != nil {
		return fmt.Errorf("failed to encode Features length: %w", err)
	}
for _, elem := range v.Features {
	
	if err := enc.EncodeString(elem); err != nil {
		return fmt.Errorf("failed to encode element: %w", err)
	}
	
	}

	if err := enc.EncodeBytes(v.Metadata); err != nil {
		return fmt.Errorf("failed to encode Metadata: %w", err)
	}

	return nil
}
func (v *BenchmarkConfig) Decode(dec *xdr.Decoder) error {

	tempHost, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Host: %w", err)
	}
v.Host = tempHost

	tempPort, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Port: %w", err)
	}
v.Port = tempPort

	tempEnableTLS, err := dec.DecodeBool()
	if err != nil {
		return fmt.Errorf("failed to decode EnableTLS: %w", err)
	}
v.EnableTLS = tempEnableTLS

	tempTimeout, err := dec.DecodeUint64()
	if err != nil {
		return fmt.Errorf("failed to decode Timeout: %w", err)
	}
v.Timeout = tempTimeout

	FeaturesLen, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Features length: %w", err)
	}
v.Features = make([]string, FeaturesLen)
for i := range v.Features {
	
	val, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode element: %w", err)
	}
	v.Features[i] = val
	
	}

	tempMetadata, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Metadata: %w", err)
	}
v.Metadata = tempMetadata

	return nil
}
var _ xdr.Codec = (*BenchmarkConfig)(nil)

func (v *BenchmarkResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
		return fmt.Errorf("failed to encode Status: %w", err)
	}

	// Switch based on key for union field Data
switch v.Status {

	case BenchmarkStatusSuccess:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	case BenchmarkStatusError:
		// void case - no data

	case BenchmarkStatusPending:
		// void case - no data


	default:
		// unknown key - encode nothing

}

	return nil
}
func (v *BenchmarkResult) Decode(dec *xdr.Decoder) error {

	tempStatus, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Status: %w", err)
	}
v.Status = BenchmarkStatus(tempStatus)

	// Switch based on key for union field Data
switch v.Status {

	case BenchmarkStatusSuccess:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	case BenchmarkStatusError:
		// void case - no data

	case BenchmarkStatusPending:
		// void case - no data


	default:
		// unknown key - decode nothing

}

	return nil
}
var _ xdr.Codec = (*BenchmarkResult)(nil)

func (v *BenchmarkSuccessResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Message); err != nil {
		return fmt.Errorf("failed to encode Message: %w", err)
	}

	return nil
}
func (v *BenchmarkSuccessResult) Decode(dec *xdr.Decoder) error {

	tempMessage, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Message: %w", err)
	}
v.Message = tempMessage

	return nil
}
var _ xdr.Codec = (*BenchmarkSuccessResult)(nil)

func (v *BenchmarkMessage) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Type)); err != nil {
		return fmt.Errorf("failed to encode Type: %w", err)
	}

	// Switch based on key for union field Payload
switch v.Type {

	case BenchmarkMsgText:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	case BenchmarkMsgBinary:
		// void case - no data

	case BenchmarkMsgVoid:
		// void case - no data


	default:
		// unknown key - encode nothing

}

	return nil
}
func (v *BenchmarkMessage) Decode(dec *xdr.Decoder) error {

	tempType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Type: %w", err)
	}
v.Type = BenchmarkMsgType(tempType)

	// Switch based on key for union field Payload
switch v.Type {

	case BenchmarkMsgText:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	case BenchmarkMsgBinary:
		// void case - no data

	case BenchmarkMsgVoid:
		// void case - no data


	default:
		// unknown key - decode nothing

}

	return nil
}
var _ xdr.Codec = (*BenchmarkMessage)(nil)

func (v *BenchmarkTextPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Content); err != nil {
		return fmt.Errorf("failed to encode Content: %w", err)
	}

	if err := enc.EncodeString(v.Sender); err != nil {
		return fmt.Errorf("failed to encode Sender: %w", err)
	}

	return nil
}
func (v *BenchmarkTextPayload) Decode(dec *xdr.Decoder) error {

	tempContent, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Content: %w", err)
	}
v.Content = tempContent

	tempSender, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Sender: %w", err)
	}
v.Sender = tempSender

	return nil
}
var _ xdr.Codec = (*BenchmarkTextPayload)(nil)

func (v *BenchmarkOperation) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.OpType)); err != nil {
		return fmt.Errorf("failed to encode OpType: %w", err)
	}

	// Switch based on key for union field Data
switch v.OpType {

	case BenchmarkOpRead:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	case BenchmarkOpWrite:
		// void case - no data

	case BenchmarkOpDelete:
		// void case - no data


	default:
		// unknown key - encode nothing

}

	return nil
}
func (v *BenchmarkOperation) Decode(dec *xdr.Decoder) error {

	tempOpType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode OpType: %w", err)
	}
v.OpType = BenchmarkOpType(tempOpType)

	// Switch based on key for union field Data
switch v.OpType {

	case BenchmarkOpRead:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	case BenchmarkOpWrite:
		// void case - no data

	case BenchmarkOpDelete:
		// void case - no data


	default:
		// unknown key - decode nothing

}

	return nil
}
var _ xdr.Codec = (*BenchmarkOperation)(nil)

func (v *BenchmarkReadResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeBool(v.Success); err != nil {
		return fmt.Errorf("failed to encode Success: %w", err)
	}

	if err := enc.EncodeBytes(v.Data); err != nil {
		return fmt.Errorf("failed to encode Data: %w", err)
	}

	if err := enc.EncodeUint32(v.Size); err != nil {
		return fmt.Errorf("failed to encode Size: %w", err)
	}

	return nil
}
func (v *BenchmarkReadResult) Decode(dec *xdr.Decoder) error {

	tempSuccess, err := dec.DecodeBool()
	if err != nil {
		return fmt.Errorf("failed to decode Success: %w", err)
	}
v.Success = tempSuccess

	tempData, err := dec.DecodeBytes()
	if err != nil {
		return fmt.Errorf("failed to decode Data: %w", err)
	}
v.Data = tempData

	tempSize, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Size: %w", err)
	}
v.Size = tempSize

	return nil
}
var _ xdr.Codec = (*BenchmarkReadResult)(nil)

