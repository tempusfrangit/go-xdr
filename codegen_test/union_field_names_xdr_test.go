//go:build ignore

// Code generated by xdrgen. DO NOT EDIT.
// Source: /Users/m/skratch/go-xdr/codegen_test/union_field_names_test.go
// Generated: 2025-07-18T16:06:32-07:00

package codegen_test

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
)

func (v *TestResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
		return fmt.Errorf("failed to encode Status: %w", err)
	}

	// Switch based on key for union field Data
	switch v.Status {

	case TestStatusSuccess:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *TestResult) Decode(dec *xdr.Decoder) error {

	tempStatus, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Status: %w", err)
	}
	v.Status = TestStatus(tempStatus)

	// Switch based on key for union field Data
	switch v.Status {

	case TestStatusSuccess:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*TestResult)(nil)

func (v *TestSuccessPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Message); err != nil {
		return fmt.Errorf("failed to encode Message: %w", err)
	}

	return nil
}
func (v *TestSuccessPayload) Decode(dec *xdr.Decoder) error {

	tempMessage, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Message: %w", err)
	}
	v.Message = tempMessage

	return nil
}

// ToUnion converts TestSuccessPayload to TestResult
func (p *TestSuccessPayload) ToUnion() (*TestResult, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode TestSuccessPayload: %w", err)
	}
	data := enc.Bytes()

	return &TestResult{
		Status: TestStatusSuccess,
		Data:   data,
	}, nil
}

// EncodeToUnion encodes TestSuccessPayload directly to union format
func (p *TestSuccessPayload) EncodeToUnion(enc *xdr.Encoder) error {
	// Encode discriminant
	if err := enc.EncodeUint32(uint32(TestStatusSuccess)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*TestSuccessPayload)(nil)

func (v *TestMessage) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Type)); err != nil {
		return fmt.Errorf("failed to encode Type: %w", err)
	}

	// Switch based on key for union field Payload
	switch v.Type {

	case TestMsgTypeText:
		if err := enc.EncodeBytes(v.Payload); err != nil {
			return fmt.Errorf("failed to encode Payload: %w", err)
		}

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *TestMessage) Decode(dec *xdr.Decoder) error {

	tempType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Type: %w", err)
	}
	v.Type = TestMsgType(tempType)

	// Switch based on key for union field Payload
	switch v.Type {

	case TestMsgTypeText:
		var err error
		v.Payload, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Payload: %w", err)
		}

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*TestMessage)(nil)

func (v *TestTextPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Content); err != nil {
		return fmt.Errorf("failed to encode Content: %w", err)
	}

	return nil
}
func (v *TestTextPayload) Decode(dec *xdr.Decoder) error {

	tempContent, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Content: %w", err)
	}
	v.Content = tempContent

	return nil
}

// ToUnion converts TestTextPayload to TestMessage
func (p *TestTextPayload) ToUnion() (*TestMessage, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode TestTextPayload: %w", err)
	}
	data := enc.Bytes()

	return &TestMessage{
		Type:    TestMsgTypeText,
		Payload: data,
	}, nil
}

// EncodeToUnion encodes TestTextPayload directly to union format
func (p *TestTextPayload) EncodeToUnion(enc *xdr.Encoder) error {
	// Encode discriminant
	if err := enc.EncodeUint32(uint32(TestMsgTypeText)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*TestTextPayload)(nil)

func (v *TestOperation) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.OpType)); err != nil {
		return fmt.Errorf("failed to encode OpType: %w", err)
	}

	// Switch based on key for union field Data
	switch v.OpType {

	case TestOpRead:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	default:
		// unknown key - encode nothing

	}

	return nil
}
func (v *TestOperation) Decode(dec *xdr.Decoder) error {

	tempOpType, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode OpType: %w", err)
	}
	v.OpType = TestOpType(tempOpType)

	// Switch based on key for union field Data
	switch v.OpType {

	case TestOpRead:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*TestOperation)(nil)

func (v *TestReadPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.Size); err != nil {
		return fmt.Errorf("failed to encode Size: %w", err)
	}

	return nil
}
func (v *TestReadPayload) Decode(dec *xdr.Decoder) error {

	tempSize, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Size: %w", err)
	}
	v.Size = tempSize

	return nil
}

// ToUnion converts TestReadPayload to TestOperation
func (p *TestReadPayload) ToUnion() (*TestOperation, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode TestReadPayload: %w", err)
	}
	data := enc.Bytes()

	return &TestOperation{
		OpType: TestOpRead,
		Data:   data,
	}, nil
}

// EncodeToUnion encodes TestReadPayload directly to union format
func (p *TestReadPayload) EncodeToUnion(enc *xdr.Encoder) error {
	// Encode discriminant
	if err := enc.EncodeUint32(uint32(TestOpRead)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*TestReadPayload)(nil)
