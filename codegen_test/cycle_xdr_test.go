//go:build ignore

// Code generated by xdrgen. DO NOT EDIT.
// Source: cycle_test.go
// Generated 3 XDR types

package main

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"

	"unsafe"
)

func (v *Node) Encode(enc *xdr.Encoder) error {
	return v.EncodeWithContext(enc, make(map[unsafe.Pointer]bool))
}

func (v *Node) EncodeWithContext(enc *xdr.Encoder, encodingSet map[unsafe.Pointer]bool) error {
	// Check for encoding loop using pointer address (prevents GC from moving objects)
	ptr := unsafe.Pointer(v)
	if encodingSet[ptr] {
		return fmt.Errorf("encoding loop detected for Node")
	}
	encodingSet[ptr] = true
	defer delete(encodingSet, ptr)

	if err := enc.EncodeUint32(v.ID); err != nil {
		return fmt.Errorf("failed to encode ID: %w", err)
	}

	if err := enc.EncodeString(v.Value); err != nil {
		return fmt.Errorf("failed to encode Value: %w", err)
	}

	// #nosec G115
	if err := enc.EncodeUint32(uint32(len(v.Children))); err != nil {
		return fmt.Errorf("failed to encode Children length: %w", err)
	}
	for _, elem := range v.Children {

		if err := elem.EncodeWithContext(enc, encodingSet); err != nil {
			return fmt.Errorf("failed to encode element: %w", err)
		}

	}

	return nil
}

func (v *Node) Decode(dec *xdr.Decoder) error {

	tempID, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ID: %w", err)
	}
	v.ID = tempID

	tempValue, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Value: %w", err)
	}
	v.Value = tempValue

	ChildrenLen, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Children length: %w", err)
	}
	v.Children = make([]*Node, ChildrenLen)
	for i := range v.Children {

		// Allocate pointer element before decoding
		v.Children[i] = &Node{}

		if err := v.Children[i].Decode(dec); err != nil {
			return fmt.Errorf("failed to decode element: %w", err)
		}

	}

	return nil
}

var _ xdr.Codec = (*Node)(nil)

func (v *FlexibleData) Encode(enc *xdr.Encoder) error {
	return v.EncodeWithContext(enc, make(map[unsafe.Pointer]bool))
}

func (v *FlexibleData) EncodeWithContext(enc *xdr.Encoder, encodingSet map[unsafe.Pointer]bool) error {
	// Check for encoding loop using pointer address (prevents GC from moving objects)
	ptr := unsafe.Pointer(v)
	if encodingSet[ptr] {
		return fmt.Errorf("encoding loop detected for FlexibleData")
	}
	encodingSet[ptr] = true
	defer delete(encodingSet, ptr)

	if err := enc.EncodeUint32(v.ID); err != nil {
		return fmt.Errorf("failed to encode ID: %w", err)
	}

	if v.Next == nil {
		return fmt.Errorf("pointer field Next is nil")
	}

	if err := v.Next.EncodeWithContext(enc, encodingSet); err != nil {
		return fmt.Errorf("failed to encode Next: %w", err)
	}

	return nil
}

func (v *FlexibleData) Decode(dec *xdr.Decoder) error {

	tempID, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ID: %w", err)
	}
	v.ID = tempID

	// Allocate pointer field before decoding
	v.Next = &FlexibleData{}

	if err := v.Next.Decode(dec); err != nil {
		return fmt.Errorf("failed to decode Next: %w", err)
	}

	return nil
}

var _ xdr.Codec = (*FlexibleData)(nil)

func (v *SimpleStruct) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.ID); err != nil {
		return fmt.Errorf("failed to encode ID: %w", err)
	}

	if err := enc.EncodeString(v.Name); err != nil {
		return fmt.Errorf("failed to encode Name: %w", err)
	}

	if err := enc.EncodeInt64(v.Count); err != nil {
		return fmt.Errorf("failed to encode Count: %w", err)
	}

	return nil
}

func (v *SimpleStruct) Decode(dec *xdr.Decoder) error {

	tempID, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ID: %w", err)
	}
	v.ID = tempID

	tempName, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Name: %w", err)
	}
	v.Name = tempName

	tempCount, err := dec.DecodeInt64()
	if err != nil {
		return fmt.Errorf("failed to decode Count: %w", err)
	}
	v.Count = tempCount

	return nil
}

var _ xdr.Codec = (*SimpleStruct)(nil)
