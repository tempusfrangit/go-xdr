//go:build ignore

// Code generated by xdrgen. DO NOT EDIT.
// Source: cross_file_discriminant_test.go
// Generated 3 XDR types

package codegen_test

import (
	"fmt"
	"github.com/tempusfrangit/go-xdr"
)

func (v *OperationResult) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(uint32(v.Status)); err != nil {
		return fmt.Errorf("failed to encode Status: %w", err)
	}

	// Switch based on key for union field Data
	switch v.Status {

	case StatusError:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	case StatusSuccess:
		if err := enc.EncodeBytes(v.Data); err != nil {
			return fmt.Errorf("failed to encode Data: %w", err)
		}

	default:
		// unknown key - encode nothing

	}

	return nil
}

func (v *OperationResult) Decode(dec *xdr.Decoder) error {

	tempStatus, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode Status: %w", err)
	}
	v.Status = ResultStatus(tempStatus)

	// Switch based on key for union field Data
	switch v.Status {

	case StatusError:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	case StatusSuccess:
		var err error
		v.Data, err = dec.DecodeBytes()
		if err != nil {
			return fmt.Errorf("failed to decode Data: %w", err)
		}

	default:
		// unknown key - decode nothing

	}

	return nil
}

var _ xdr.Codec = (*OperationResult)(nil)

func (v *SuccessPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeString(v.Message); err != nil {
		return fmt.Errorf("failed to encode Message: %w", err)
	}

	return nil
}

func (v *SuccessPayload) Decode(dec *xdr.Decoder) error {

	tempMessage, err := dec.DecodeString()
	if err != nil {
		return fmt.Errorf("failed to decode Message: %w", err)
	}
	v.Message = tempMessage

	return nil
}

// ToUnion converts SuccessPayload to OperationResult
func (p *SuccessPayload) ToUnion() (*OperationResult, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode SuccessPayload: %w", err)
	}
	data := enc.Bytes()

	return &OperationResult{
		Status: StatusSuccess,
		Data:   data,
	}, nil
}

// EncodeToUnion encodes SuccessPayload directly to union format
func (p *SuccessPayload) EncodeToUnion(enc *xdr.Encoder) error {

	// Encode discriminant
	if err := enc.EncodeUint32(uint32(StatusSuccess)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil

}

var _ xdr.Codec = (*SuccessPayload)(nil)

func (v *ErrorPayload) Encode(enc *xdr.Encoder) error {

	if err := enc.EncodeUint32(v.ErrorCode); err != nil {
		return fmt.Errorf("failed to encode ErrorCode: %w", err)
	}

	return nil
}

func (v *ErrorPayload) Decode(dec *xdr.Decoder) error {

	tempErrorCode, err := dec.DecodeUint32()
	if err != nil {
		return fmt.Errorf("failed to decode ErrorCode: %w", err)
	}
	v.ErrorCode = tempErrorCode

	return nil
}

// ToUnion converts ErrorPayload to OperationResult
func (p *ErrorPayload) ToUnion() (*OperationResult, error) {
	buf := make([]byte, 1024) // Initial buffer size
	enc := xdr.NewEncoder(buf)
	if err := p.Encode(enc); err != nil {
		return nil, fmt.Errorf("failed to encode ErrorPayload: %w", err)
	}
	data := enc.Bytes()

	return &OperationResult{
		Status: StatusError,
		Data:   data,
	}, nil
}

// EncodeToUnion encodes ErrorPayload directly to union format
func (p *ErrorPayload) EncodeToUnion(enc *xdr.Encoder) error {

	// Encode discriminant
	if err := enc.EncodeUint32(uint32(StatusError)); err != nil {
		return fmt.Errorf("failed to encode discriminant: %w", err)
	}

	// Encode payload
	if err := p.Encode(enc); err != nil {
		return fmt.Errorf("failed to encode payload: %w", err)
	}

	return nil

}

var _ xdr.Codec = (*ErrorPayload)(nil)
